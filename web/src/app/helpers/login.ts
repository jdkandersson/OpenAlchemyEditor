import { RouterEvent, NavigationEnd } from '@angular/router';

const LOGIN_BASE = 'https://login.openalchemy.io';
const CLIENT_ID = '1ahpcjva4jst9385sk7pv71nmb';
const RESPONSE_TYPE = 'code';
const AUTHORIZATION_GRANT_TYPE = 'authorization_code';
export const AUTHORIZATION_HEADERS = {
  'Content-Type': 'application/x-www-form-urlencoded',
};
export const TOKEN_URI = `${LOGIN_BASE}/oauth2/token`;
const REFRESH_GRANT_TYPE = 'refresh_token';
const SIGN_IN_COMPLETE = 'sign-in-complete';

export interface State {
  pathname: string;
  salt: string;
}

/**
 * Generate the state to be stored and passed along with the login
 * @param pathname The current pathname before login
 */
export function calculateState(pathname: string): string {
  const salt = new Array(10)
    .fill(0)
    .map(() => Math.random())
    .map((value) => value.toString(36))
    .map((value) => value.substr(2))
    .join('');
  const state = JSON.stringify({ pathname, salt } as State);
  return btoa(state);
}

function calculateRedirectUri(origin: string): string {
  return `${origin}/${SIGN_IN_COMPLETE}`;
}

/**
 * Calculate the href to redirect the page to for login
 * @param origin The current window origin.
 */
export function calculateRedirectHref(origin: string, state: string): string {
  const base = `${LOGIN_BASE}/login`;
  const redirectUri = calculateRedirectUri(origin);

  return `${base}?response_type=${RESPONSE_TYPE}&client_id=${CLIENT_ID}&redirect_uri=${redirectUri}&state=${state}`;
}

/**
 * Filter for NavigationEnd events
 * @param event Event generated by the angular router
 */
export function isNavigationEnd(event: RouterEvent): boolean {
  return event instanceof NavigationEnd;
}

/**
 * Filter for NavigationEnd events to sign in complete
 * @param event NavigationEnd event from the angular router
 */
export function isSignInComplete(event: NavigationEnd): boolean {
  if (!event) {
    return false;
  }
  if (!event.url) {
    return false;
  }
  return event.url.startsWith(`/${SIGN_IN_COMPLETE}`);
}

function urlFromEvent(event: NavigationEnd): URL {
  return new URL(event.url, 'https://a.a');
}

/**
 * Check that the state is valid after sign in
 * @param event The event to check
 * @param storedState The state as it was stored before sign in
 */
export function isStateValid(
  event: NavigationEnd,
  storedState: string
): boolean {
  if (!storedState || !event) {
    return false;
  }
  const url = urlFromEvent(event);
  if (!url.searchParams.has('state')) {
    return false;
  }
  const urlState = url.searchParams.get('state');
  return urlState === storedState;
}

/**
 * Retrieve the code from the navigation event
 * @param event The event to retrieve the code from
 */
export function getCode(event: NavigationEnd): string {
  const url = urlFromEvent(event);
  if (!url.searchParams.has('code')) {
    throw 'sign in complete without code from sign in';
  }
  return url.searchParams.get('code');
}

/**
 * Calculate the body of the post request to get the tokens
 * @param code The code returned from sign in
 * @param origin The current window origin
 */
export function calculatePostBody(code: string, origin: string): string {
  const redirectUri = calculateRedirectUri(origin);
  return `grant_type=${AUTHORIZATION_GRANT_TYPE}&client_id=${CLIENT_ID}&code=${code}&redirect_uri=${redirectUri}`;
}

export interface Tokens {
  access_token: string;
  refresh_token: string;
  id_token: string;
  token_type: string;
  expires_in: number;
}

export interface TokensMeta extends Tokens {
  currentTime: number;
}

export function addMetaToTokens(tokens: Tokens): TokensMeta {
  return {
    ...tokens,
    currentTime: parseInt((new Date().getTime() / 1000).toFixed()),
  };
}

/**
 * Get the state from the navigation end event
 * @param event The navigation end event
 */
export function getState(event: NavigationEnd): State {
  const url = urlFromEvent(event);
  if (!url.searchParams.has('state')) {
    throw 'sign in complete without state from sign in';
  }
  const urlState = url.searchParams.get('state');
  const decodedState = atob(urlState);
  return JSON.parse(decodedState);
}

/**
 * Get the path from before sign in was kicked off
 * @param state The state before sign in was started
 */
export function getPreviousPath(state: State): string {
  return state.pathname;
}
